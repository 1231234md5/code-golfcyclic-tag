package routes

import "math/rand"

func pangramGrep() (args []string, out string) {
	all := [][]string{
		{"1", "A large fawn jumped quickly over white zinc boxes."},
		{"1", "A wizard's job is to vex chumps quickly in fog."},
		{"1", "Bright vixens jump; dozy fowl quack."},
		{"0", "Five or six big jet planes zoomed past the tower."},
		{"1", "Fix problem quickly with galvanized jets."},
		{"1", "Go, lazy fat vixen; be shrewd, jump quick."},
		{"1", "Jumpy halfling dwarves pick quartz box."},
		{"0", "My ex pub quiz crowd gave happy thanks."},
		{"1", "Pack my box with five dozen liquor jugs."},
		{"1", "The five boxing wizards jump quickly."},
		{"1", "The jay, pig, fox, zebra and my wolves quack!"},
		{"0", "The quick brown fox jumps over a lazy cat."},
		{"1", "Waxy and quivering, jocks fumble the pizza."},
		{"1", "When zombies arrive, quickly fax judge Pat."},
	}

	// Add some autogenerated cases.
	for c := 0; c < 9; c++ {
		perm := rand.Perm(26)
		bytes := []byte{}

		for _, x := range perm {
			if rand.Intn(2) == 0 {
				bytes = append(bytes, 'A'+byte(x))
			} else {
				bytes = append(bytes, 'a'+byte(x))
			}
		}

		match := "0"

		switch c % 3 {
		case 0:
			match = "1"
		// Increment or decrement a random char.
		case 1:
			if i := rand.Intn(26); bytes[i] == 'A' || bytes[i] == 'a' {
				bytes[i]++
			} else {
				bytes[i]--
			}
		// Set a random char to the flipped case of the previous.
		case 2:
			if i := rand.Intn(25); bytes[i] > 'Z' {
				bytes[i+1] = bytes[i] - 32
			} else {
				bytes[i+1] = bytes[i] + 32
			}
		}

		all = append(all, []string{match, string(bytes)})
	}

	// Shuffle the whole set.
	for i := range all {
		j := rand.Intn(i + 1)
		all[i], all[j] = all[j], all[i]
	}

	for _, v := range all {
		args = append(args, v[1])

		if v[0] == "1" {
			out += v[1] + "\n"
		}
	}

	// Drop the trailing newline.
	out = out[:len(out)-1]

	return
}
